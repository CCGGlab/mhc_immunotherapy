library(tidyverse)

# Read data
# ==========

# Mapping table ENSG -> HGNC
# (created using create_ENSG_HGNC_map_table.R)
ENSG_HGNC_map_table <- readRDS("data/ENSG_HGNC_map_table.rds") %>%
  select(gene_id = ensembl_gene_id, gene = external_gene_name, gene_biotype)

# Genes that remain in Liu data after filter criteria
# (Filter applied for best consistency with their method)
# (Excludes snoRNA genes among others)
liu_genes <- read_tsv("downloads/pub/liu_2019/rnaseq_rawcounts.txt") %>%
  rename(gene := 1) %>%
  pull(gene) %>% 
  unique
# => 25594 genes

# Read "txi" objects
# (generated by "create_txi_objects.R")
txi_objects <- readRDS("data/txi_objects_rsem.rds")

# Process data for Combat-Seq
# ===========================
# For Combat-Seq, we need raw RNA-Seq counts
raw_counts <- txi_objects %>%
  imap(~rename_with(as.data.frame(.x$counts), function(x) paste0(.y, '.', x))) %>%
  bind_cols()

# Convert to matrix
count_matrix <- raw_counts %>%
  as.matrix

# Create vector with "groups" (study).
batch <- as.factor(str_split(colnames(raw_counts), '\\.', simplify = T)[,1])

# Apply Combat-Seq
# ================

library(sva) # package that implements Combat-Seq

# Basic usage without covariates
adjusted_counts <- ComBat_seq(counts=count_matrix, batch=batch)

# Parse Combat-Seq results
# =========================

# Split adjusted count matrix per study and remove the study prefix
res <- batch %>%
  # Which batches (studies) exist
  levels %>%
  set_names %>%
  # Extract samples belonging to this study
  map(~as.data.frame(adjusted_counts[,batch == .])) %>%
  # Rename columns of count matrix for each study: remove prefix
  map(~rename_with(., function(x) str_remove(x, '^.*?\\.')))

# Convert counts to TPMs
# Additional processing to map Ensembl gene IDs to HGNC IDs
tpm_dfs <- txi_objects %>%
  names %>%
  set_names %>%
  map(function(study) {
    # Remove genes with effective gene length == 0
    gene_lengths_all <- rowMeans(txi_objects[[study]]$length, na.rm = T)
    zero_length_genes <- names(gene_lengths_all[gene_lengths_all == 0])
    length(zero_length_genes)
    # => 2084 genes have effective gene length = 0, according to RSEM
    
    # Mapping from ENSG IDs to HGNC IDs
    # added column "keep" indicates whether the gene:
    # - Was retained in the Liu study (consistency with non batch corrected results)
    # - Has an effective gene length > 0 (as reported by RSEM)
    current_gene_mapping <- txi_objects[[study]]$counts %>%
      rownames %>%
      as_tibble_col("gene_id") %>%
      left_join(ENSG_HGNC_map_table, by = "gene_id") %>%
      mutate(keep = (gene %in% liu_genes) & !(gene_id %in% zero_length_genes))
    
    # Check assertions.
    # genes in rows of count matrix should equal the genes in current_gene_mapping
    stopifnot(all(rownames(txi_objects[[study]]$counts) == current_gene_mapping$gene_id))
    stopifnot(all(rownames(res[[study]]) == current_gene_mapping$gene_id))
    
    # Filter genes based on criteria defined above ("keep" column)
    # Gene length corresponds to the average gene length (reported by RSEM) for that gene
    # (otherwise done implicitly by convertCounts, see documentation)
    cnt_matr <- as.matrix(res[[study]][current_gene_mapping$keep,])
    gene_lengths <- rowMeans(txi_objects[[study]]$length[current_gene_mapping$keep,], na.rm = T)
    
    # Check assertion:
    # Genes in gene length vector should correspond to the rows in the count matrix
    stopifnot(names(gene_lengths) == rownames(cnt_matr))
    
    # Convert from raw counts to TPMs:
    # requires gene length 
    tpm <- DGEobj.utils::convertCounts(cnt_matr, unit = "TPM", geneLength = gene_lengths)
    
    # Convert ENSG to HGNC IDs and handle non-unique mappings
    tpm_hgnc <- tpm %>%
      as.data.frame %>%
      rownames_to_column("gene_id") %>%
      left_join(ENSG_HGNC_map_table, by = "gene_id") %>%
      select(-gene_id) %>%
      # Only keep protein coding genes
      filter(gene_biotype == "protein_coding") %>%
      select(-gene_biotype) %>%
      select(gene, everything()) %>%
      # Mapping ENSG to HGNC might not be unique
      # Keep the entry with the highest number of reads in total
      group_by(gene) %>%
      summarise(across(everything(), max)) %>%
      ungroup %>%
      column_to_rownames("gene")
    
    tpm_hgnc
  })

# Save results
# =============
saveRDS(tpm_dfs, "data/ICB_expr_rsem_converted-to-tpm_batch.rds")
